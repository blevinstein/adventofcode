use std::env;
use std::fs;
use std::collections::VecDeque;
use regex::Regex;

use y2024::Pos;
use y2024::grid_find;

fn parse_keyboard(s: &str) -> Vec<Vec<char>> {
    s.trim().split("\n").map(|row| row.chars().collect()).collect()
}

// Given a keypad and a code to type, expand the code into directions
fn expand(keypad: &Vec<Vec<char>>, code: &str) -> String {
    let mut result: Vec<(Pos, String)> = Vec::new();
    let mut queue: VecDeque<(Pos, String)> = VecDeque::from([(grid_find(&keypad, &'A'), "")]);
    let mut position = grid_find(&keypad, &'A');

    for c in code.chars() {
        let new_position = grid_find(&keypad, &c);
        let mut offset = new_position.sub(&position);
        while offset.x < 0 {
            result.push('<');
            offset.x += 1;
        }
        while offset.x > 0 {
            result.push('>');
            offset.x -= 1;
        }
        while offset.y < 0 {
            result.push('^');
            offset.y += 1;
        }
        while offset.y > 0 {
            result.push('v');
            offset.y -= 1;
        }
        result.push('A');
        position = new_position;
    }

    result
}

fn expand_three(code: &str) -> String {
    static numeric_keypad = parse_keyboard("789\n456\n123\nx0A");
    static directional_keypad = parse_keyboard("x^A\n<v>");

    let a = dbg!(expand(&numeric_keypad, &code));
    let b = dbg!(expand(&directional_keypad, &a));
    let c = dbg!(expand(&directional_keypad, &b));
    c
}

fn main() {

    /*
     * TODO
     * 1. Expanding a single value is insufficient, we must expand ALL possible sequences, because
     *    on further expansion, one may be shorter.
     * 2. We must prevent movement onto invalid key positions '_'.
     */

    let raw_input = fs::read_to_string(env::args().nth(1).expect("Missing filename input"))
        .expect("Failed to read input");

    let codes: Vec<&str> = raw_input.trim().split("\n").collect();

    let number_re = Regex::new(r"\d+").unwrap();

    let complexity = |code| {
        dbg!(code);
        number_re.find(code).unwrap().as_str().parse::<usize>().unwrap() * expand_three(code).len()
    };

    let mut sum = 0;
    for code in codes {
        let value = dbg!(complexity(code));
        sum += value;
    }
    //let sum = codes.iter().map(|code| complexity(code)).reduce(|acc, el| acc + el).unwrap();
    println!("Sum of complexity is {sum}");
}
